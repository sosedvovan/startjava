package com.urise.webapp;

import com.urise.webapp.model.Resume;

import java.util.*;

public class MainCollections {

    private static final String UUID_1 = "uuid1"; //созд переменные String
    private static final Resume RESUME_1 = new Resume(UUID_1, "Name1" );//созд объекты для массива collection

    private static final String UUID_2 = "uuid2"; //для @Before
    private static final Resume RESUME_2 = new Resume(UUID_2, "Name2" );

    private static final String UUID_3 = "uuid3"; //static- тк они одинак в каждом методе
    private static final Resume RESUME_3 = new Resume(UUID_3, "Name3");

    private static final String UUID_4 = "uuid4";
    private static final Resume RESUME_4 = new Resume(UUID_4, "Name4" );



    //-----------------------------------------------------------------------------

    public static void main(String[] args) {

        Collection<Resume> collection = new ArrayList<>();
        collection.add(RESUME_1);
        collection.add(RESUME_2);
        collection.add(RESUME_3);


        /**
          //сделаем итерацию в цикле foreach и добавим условие и получим ошибку:
        for(Resume r : collection){
            System.out.println(r);
            if(Objects.equals(r.getUuid(), UUID_1)){
                collection.remove(r);//в этой строке есть попытка изменения коллекции при итерации - будет ошибка:
                //- ConcurrentModificationException -- надо использовать итератор
            }
        }
         */

        /**
        //ЧТОБЫ ЧТО ТО МОДИФИЦИРОВАТЬ ИЛИ УДАЛИТЬ В КОЛЛЕКЦИИ НАДО ИСП ИТЕРАТОР:
        //ИТЕРАТОР - это интерфейс, кот имеет 3-а метода: hasNext() и next() и remove()
        //итератор наследуется от итерейбл(фактори метод кот возвращает итератор)
        // и позволяет делать цикл фор-ич в (скобках)которого:
        //Ява вызывает итератор
        //те еслибы Резюме имплеменировала итэрейбл, то в нем можно было исп фор-ич,
        // а если нет - тогда в while можно (см ниже)
        //коллекции экстендятся от итерейбл
        //у одного листа можно создать несколько итераторов и итерироваться по разному
        //напр в ArrayList можно найти метод итератор, кот ссылается на внутренний класс(см внизу)
         */

        //теперь сделаем итерацию в итераторе и добавим условие в цикле while:
        Iterator<Resume> iterator = collection.iterator();//переменной iterator присвоили
                                                        //нашу коллекцию
        while (iterator.hasNext()) {//hasNext() - есть ли следующий элемент в коллекции
            Resume r = iterator.next();//next() - перевести курсор и взять следующий элемент в коллекции
            //переменной r присваиваем следующий элемент в итераторе
            //первоначально курсор стоит перед [0] элементом и его надо перевести на него ->[0]
            System.out.println(r);
            if(Objects.equals(r.getUuid(), UUID_1)){
                iterator.remove();//попытка изменения коллекции при итерации - все OK
            }
        }

        System.out.println(collection.toString());//посмотрели, что RESUME_1 удалилось.


      /**
        //теперь сделаем итерацию в итераторе и добавим условие в цикле do-while:
        //но в этом случае- если коллекция будет пустая - то выбросится рантайм(в его описании нет throws)  -
        // эксепшн- NoSuchElementException -> цикл while будет лучше

        do {
            Resume r = iterator.next();//next() - перевести курсор и взять следующий элемент в коллекции
            //переменной r присваиваем следующий элемент в итераторе
            //первоначально курсор стоит перед [0] элементом и его надо перевести на него ->[0]

            System.out.println(r);
            if(Objects.equals(r.getUuid(), UUID_1)){
            iterator.remove();//попытка изменения коллекции при итерации - все OK
            }

        }while (iterator.hasNext());//hasNext() - есть ли следующий элемент в коллекции

        */



        //создадим и проитерируем Map(ключ-значение):
        Map<String, Resume> map = new HashMap<>();
        map.put(UUID_1, RESUME_1);
        map.put(UUID_2, RESUME_2);
        map.put(UUID_3, RESUME_3);

        //проитерируемся по map сначала неправильно:
        //здесь каждый раз ходим в map за значением.
        for (String uuid : map.keySet()){//keySet()-взять ключ
            System.out.println(map.get(uuid));//get(uuid)-вернет объект RESUME_{i} со значением поля - uuid{i})
        }

        //проитерируемся правильно:
        //entry - здесь будет хранить уже пару: ключ-значение целиком.
        for (Map.Entry<String, Resume> entry : map.entrySet()){
            System.out.println(entry.getValue());//entry.getValue() тоже вернет объект RESUME_{i}
        }
        //Entry - это служебный внутренний интерфейс Map, кот. содержит 3-и метода:
        // getKey()   getValue()    setValue(V var1)


        //далее пример вложенного статического класса:
        //выделили левую часть присвоения и Alt+Ctrl+V это экстракт вариэйбл - увидели тип RESUME_?
        List<Resume> resumes = Arrays.asList(RESUME_1, RESUME_2, RESUME_3);
        //вернулся обычный аррай лист и с ним можно например сделать:
        //resumes.remove(1);//закоментировали чтобы небыло Exception при run
        System.out.println(resumes);//выбросится UnsupportedOperationException -операция не поддерживается
        //тк мы на самом деле обратились к внутреннему статическому классу внутри Arrays когда передавали
        //варарги (RESUME_1, RESUME_2, RESUME_3)- вариативное кол-во аргументов(идут на последнем месте только)
        //и нам вернулся не привычный ArrayList а ArrayList из Arrays(статический внутр класс),
        // в кот не реализован remove() и add(). и в нем нет скрытой ссылки на его внешний класс тк он статический
        //то если нам нужен доступ к внешнему классу- используем не статический внутренний класс

    }
}

/**
 * ConcurrentModificationException- когда одновременно кто-то итерируемся по коллекции
 * а кто-то  патается в ней что-то поменять
 *
 *
 * от интерфейса Collection наследуются интерфейсы Set и List. В Set не может быть дубликатов
 * то если из List надо удалить дубликаты мы делаем List.setAll() и Set.addAll()
 * (List скопировали в Set)
 * те Set нужен только для уникальности
 *
 * у Set есть 2-е главные реализации- HashSet и TreeSet.(на основе AbstractSet)
 * у элементов Set нет индексов
 *
 * реализация TreeSet основана на TreeMap а HashSet на HashMap
 * те все происходит на основе двоичного поиска по древовидной структуре
 * те из каждой ветки растет еще две ветки, есть левая сторона и есть правая
 * и с пом лефт и райт мы можем дойти до любого значения
 *
 * от Set наследуется еще SortedSet, кот расширяет Set, и у него собственная реализация TreeSet
 * так же основанная на двоичном поиске
 *
 * то Set отличается от других Collection тем что в нем элементы не дублируются
 * а list отличается от других Collection тем что в нем появляются индексы
 * те мы можем сказать get(int index), remove(int index).
 *
 * главные реализации List  это ArrayList И LinkedList
 *
 * LinkedList кроме служебных интерфейсов имплементирует еще и Deque - это Queue-очередь,
 * которая может с двух сторон удалять-добавлять. те LinkedList это дву-связанный список-
 * те мы можем идти-итерировать сначала или сконца
 * то LinkedList нам нужен чтобы удалять элементы из середины, тк при этом не надо сдвигать
 * вправо, а просто в соседних элементах перепишутся ссылки
 *
 * в LinkedList в оберточке каждого элемента присутствуют еще 2-е ссылки
 * те если есть 100 элементов, то в LinkedList будет 300-та, а в ArrayList- 100 так и будет
 *
 * ArrayList самая простая структура, внутри её находится простой массив (из 10-ти ячеек)
 * и когда заканчивается место в массиве, то ArrayList автоматически-динамически увеличивает
 * свой внутренний массив((старый * 3) / 2 + 1) путем копирования данных из старого
 * массива в новый.
 * но в ArrayList операции вставки и удаления происходят с пом сдвига, поэтому
 * надо брать LinkedList.
 * то ArrayList используем когда надо просто итерировать по индексу без вставок-удалений.
 *
 *
 * Перейдем к Map. На основе Map устроены Set'ы.( реализация TreeSet основана на TreeMap
 * а HashSet на HashMap)
 * Map<K,V> Map параметризован парой- ключ-значение(ассоциативный массив)-
 * особенность- ключи также уникальны как и у Set'а значения(поэтому в Set нет дубликатов),
 * (в Set'е элемент - это ключ Map'ы (с заглушкой в value), поэтому есть уникальность),
 * по ключу мы можем класть какое то значение.
 * те если по ключу uuid класть Resume, то при update мы просто по этому ключу
 * положим другой объект.
 * Map используется в связке- день(ключ)->события(накапливаем значения)-
 * это для анализа- в какие дни произошли определенные собтия
 * те каждому дню будет соответствовать список событий.
 *
 * в Map пользуются в основном SortedMap и HashMap.
 *
 * от Map наследуется еще SortedMap(сортировка по Ключу?) кот расширяет Map и у него
 * собственная реализация TreeMap так же основанная на двоичном поиске(по аналогии с TreeSet)
 *
 * HashMap реализует интерфейс Map. Это когда порядок не важен, а достаточно ключа и значения.
 *
 * КОНТРАКТ МЕЖДУ ИКВАЛС И ХЕШ-КОД: ЕСЛИ ИКВАЛС ТРУ, ТО И ХЕШ-КОДЫ РАВНЫ, А НАОБОРОТ НЕ ОБЯЗАТЕЛЬНО
 * то если бы это не выполнялось, то структуры основанные на HashMap и HashSet не работали бы
 *
 * CTRL + E - показать последние классы и выбрать один
 *
 * Как устроен SortedMap:
 * по аналогии с SortedSet- сортировка идет бинарным поиском - черно-красным деревом,
 * только там не строгая балансировка-сортировка- те на 1 или на 2 элемента может отличаться,
 * но если более- происходит перебалансировка-пересортировка.
 *
 *
 * Как устроен HashMap:
 * внутри его есть карзины-бакеты-Entry(hash, key, next-ссылка на след., value).
 * первоначальный размер - 16 ячеек, когда растет-умножается на 2
 * когда мы туда что-то кладем-put()- то сначала находим номер корзинки
 * по key вычисляется - hash.(кол-во ячеек в коллекции делится на вычесленный Hash нацело-
 * это и есть номер ячейки, куда попадет пара ключ-значение) + еще битики перемешиваются-
 * это связанно с умножением на 2 при увеличении коллекции
 * если ключи одинаковые, то и Hash одинаков, значит пара попадет в одну корзину,
 * а там распределиться как однонаправленный линкедЛист(для этого исп. next-ссылка на след.)
 * те в карзине может быть несколько элементов
 *
 * и когда мы берем get() по ключу, то HashMap сначала считает hash этого ключа,
 * по этому hash-у вычисляет корзинку, заходит в эту карзинку, где хранятся несколько Резюме
 * и начинает искать нужное Резюме-сравнивать с пом Equals
 * то если контракт му Equals и Hash не будет работать- HashMap и HashSet поломаются
 *
 * put работает аналогично- вычисляет нужную корзину по hash с key, заносит в корзинку элемент
 * и начинает сравнивать ключ с другими ключами, если есть совпадение, то старое value затирается,
 * и на его место записывается новое, тк ключ- уникален. Если равенства ключа не нашли, то пара просто
 * добавляется в список.
 * В HashMap НЕТ СОРТИРОВКИ. Мы храним данные на основе Hash-а. Следовательно в ключе должны быть
 * определен Hash и Equals. те у нас ключ- uuid-> в Resume переопределяем  Hash и Equals.
 * то класс Resume мы начинаем использовать как ключ к структурам HashMap и HashSet.
 *
 * СОРТИРОВАННЫЕ SortedSet и SortedMap - это реализации TreeSet и TreeMap на основе двоичного дерева
 *
 * Резюме: в HashMap данные хранятся в массиве, в котором есть бакеты с листами и в этих листах хранятся те пары,
 * кот попали в этот бакет(карзину). Внутри листов происходит проверка, что все ключи уникальны и далее
 * или добавляем или перезатираем.
 * И чем лучше реализован HashSet в Яве, тем лучше работает HashMap кагда распределяет данные по карзинам-
 * если коллизия-и все данные попадают в одну корзину, то HashMap вырождается в обыкновенный LinkedList,
 * и в этой связи в 8-ой Яве добавили: при определенном размере этого LinkedList-а, он преобразуется
 * в TreeSet.
 *
 * Оптимально, когда в каждой корзине лежит по одной паре(хорошая балансировка-О(1)). Есть LoadFactor = 0,75 -
 * те когда HashMap заполнен больше, чем на 75%, происходит двукратное увеличение его размера
 * для уменьшения колличества коллизий О(n) (О от ln по основанию n - в 8-ой Java).
 */

/**
 *ВЛОЖЕННЫЕ КЛАССЫ- может быть один уровень вложения в Ява
 * делятся на статические и не статические
 *
 * не статический: объект этого класса связан с внешним классом - в его поле есть ссылка на внешний класс-
 * напр- итератор в АррайЛисте имеет ссылку(спрятанную Явой) на АррайЛист и может поэтому его итерировать
 *
 *статический - пример в служебном классе Arrays - метод asList()- есть в коде в этом классе пример.
 * то если нам нужен доступ к внешнему классу- используем не статический внутренний класс
 *
 * не статические вложенные классы называются внутренними
 *
 * РАЗНОВИДНОСТЬ вложенных и внутренних классов- ЛОКАЛЬНЫЕ И АНОНИМНЫЕ
 *
 * ЛОКАЛЬНЫЙ- класс кот объявлен в теле метода(внутри операндов) - редкая штука-
 * там происходит инкапсуляция какой-то логики. в теле метода, после локального класса(вне его)
 * можно создавать объекты этого локального класса и через них обращаться к методам этого локального класса.
 * --> крассивее код будет (инкапсулируем какие-то методы и данные связанные по смыслу(напр ENAM), которые больше
 * нигде не используем- из них делаем локальный класс) Такие классы Ява может создавать в стеке- если увидит,
 * что  ссылка на этот класс никуда из метода не уходит
 *
 *АНОНИМНЫЕ классы используем в коде этого класса(на примере сортировки)
 */