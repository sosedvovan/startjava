package com.urise.webapp.util;

public class LazySingleton {

   volatile private static LazySingleton INSTANCE;//ленивый

    private LazySingleton() {
    }

    //Реализация Initialization-on-demand holder idiom:
    //синглетон INSTANCE инициализируется во внутреннем классе при его загрузке класслоадером
    //при обращении к нему первого потока. и с пом внутреннего устройства Ява
    //выстраивается очередь потоков и без синхронизатора.
    private static class LazySingletonHolder {
        private static final LazySingleton INSTANCE = new LazySingleton();

        public static LazySingleton getInstance(){
            return INSTANCE;
        }
    }


}

/**
 * public class LazySingleton {
 * private static final LazySingleton INSTANCE = new LazySingleton();//не ленивый-сразу инициализируем
 *  private LazySingleton() {
 *     }
 *  public static LazySingleton getInstance(){
 *             return INSTANCE;
 *         }
 *
 *
 *вызов объекта этого класса- синглетона из другого класса:
 *               LazySingleton.getInstance();
 *
 * у этого класса может быть только один объект на всю джава машину
 * в контексте одного класс-лоудера
 *
 * ленивый синглетон:
 * ссылка на него инициализируется по требованию в сеттере, а не сразу:
 * private static final LazySingleton INSTANCE;
 * public static LazySingleton getInstance(){
 *          if(INSTANCE==null) {
 *              INSTANCE = new LazySingleton();
 *          }
 *         return INSTANCE;
 *     }
 *
 *
 * в многопоточном приложении геттер должен быть синхронизирован
 * тк каждый поток может создать свой INSTANCE:
 public static synchronized LazySingleton getInstance(){
 *          if(INSTANCE==null) {
 *              INSTANCE = new LazySingleton();
 *          }
 *         return INSTANCE;
 *     }
 *
 * НО ЭТО БУДЕТ ДОЛГИЙ ПРОЦЕСС тк каждый поток будет делать блокировку сеттера.
 * Модифицируем сеттер: под :Double checked locking
 public static LazySingleton getInstance(){
 *          if(INSTANCE==null) {
 *          synchronized (LazySingleton.class){
 *              if(INSTANCE==null) {
 *              INSTANCE = new LazySingleton();
 *          }
 *          }
 *          }
 *         return INSTANCE;
 *     }
 * ТЕПЕРЬ ЕСЛИ ОБЪЕКТ  INSTANCE уже существует до блока блокировки(synchronized)
 * поток не дойдет
 *
 * НО ЕСЛИ МЫ В МНОГОПОТОЧНОМ ПРИЛОЖЕНИИ ДОБАВИМ В КЛАСС СИНГЛЕТОНА
 * вычисляемое поле, например:
 * double sin = Math.sin(13.);
 * и наш INSTANCE должен быть инициализирован после инициализации этого поля,
 * то в МНОГОПОТОЧНОМ ПРИЛОЖЕНИИ(в однопоточном все ок)
 * из-за реордиринга(меняет строки кода местами) Ява, какой-то поток может получить объект INSTANCE
 * без инициализации поля sin(те в этом потоке поле sin будет без значения)
 * Поэтому переработали ЯваМемориМодел:
 * тк процессор выполняет инструкции быстрее чем может достать что-либо из памяти-
 * -ввели хеши. И если много потоков работают с одним зашаренным объектом(напр счетчик)
 * то в разных хешах разные потоки могут присвоить этому одному счетчику разные данные
 * и результат не предсказуем. поэтому надо сделать INSTANCE volatile:
 * volatile private static final LazySingleton INSTANCE;
 * и для Ява машины это будет запретом на реордиринг
 * и этот объект INSTANCE И КОД С НИМ СВЯЗАННЫЙ будет хранится только в общем хеше.
 * **********************************************************************
 * например декларируем int i; (до INSTANCE)в коде с последующим ее использованием
 * в блоке synchronized сеттера:
 * int i;
 * volatile private static final LazySingleton INSTANCE;
 *
 public static LazySingleton getInstance(){
 *          if(INSTANCE==null) {
 *          synchronized (LazySingleton.class){
 *              if(INSTANCE==null) {
 *              int i = 13;
 *              INSTANCE = new LazySingleton();
 *          }
 *          }
 *          }
 *         return INSTANCE;
 *     }
 * БЕЗ volatile НА INSTANCE, В КАКОМ-НИБУДЬ ПОТОКЕ, ИЗ-ЗА РЕОРДИРЕНГА ЯВА
 * В ЛОКАЛЬНОМ БЛОКЕ synchronized МОЖЕТ НЕ ОКАЗАТЬСЯ ЗАДЕКЛАРИРОВАННОЙ
 * ПЕРЕМЕННОЙ int i. И БУДЕТ ОШИБКА РАНТАЙМА.
 *
 * return INSTANCE; в сеттере означает что мы можем ее прочитать только
 * из главного хеша. а б других хешах она должна быть сброшенна и перезаписанна
 * значением из главного. То же самое Ява будет делать и с другими переменными,
 * которые декларируются рядом с INSTANCE(связанный с INSTANCE код)
 * те не обязательно все переменные помечать с пом. volatile.
 * тк при чтении снепшота переменной volatile(сразу нескольких переменных)
 * они не изменятся до их записи
 * и отдельный поток будет видеть состояние зашаренных переменных,
 *  в synchronized {...} блоке таким, каким его сделал предидущий поток(хеппинг-бефо)
 *  тк используется один главный хеш
 *
 *  это и есть запись из volatile и чтение из volatile.
 *
 *  а synchronized - это получение потоками поочереди лока - правом
 *  блокировать части кода на время его выполнения текущим потоком.
 *  потоки должны встать в очередь за этим правом на объекте-мониторе очереди.
 *  И благодаря synchronized чтение и запись из volatile происходит по очереди
 *  каждым потоком (чтение и запись из volatile без synchronized не синхронизированно)
 *  те volatile гарантирует нам только актуальное значение для потоков
 *  (volatile борется со многими хешами-пишет в один, и реордерингом Ява)
 *  и без synchronized это актуальное значение могут получить
 *  одновременно несколько потоков (и инкрементить счетчик со 100 до 101 одновременно)
 *  те счетчик не будет меняться в зависимости от предидущего состояния
 *
 *  переменную булеан volatile можно использовать как флаг для прерывания цикла вычислений
 *  в потоке из главного потока(это не синхронизация, а чтение актуальных ресурсов)
 *
 *
 * ПРО final
 * В Ява есть правило- потоки и объекты не могут получить досступ к объкту класса,
 * если в этом классе есть final поля и они не инициализированны. те доступ возможен
 * только полсле инициализации таких полей.
 * и, получается, что можно не ставить volatile на INSTANCE,
 * а сделать все переменные этого класса final.
 * Это будет гарантией, что они проинициализированны.
 * ссылка INSTANCE в synchronized блоке не будет проинициализированна,
 * пока final переменные не будут проинициализированны-
 * -те боремся с реордирингом Явы
 *
 * а после инициализации INSTANCE, заработает его volatile
 *
 *
 * то ЯваМемори модель это хеппинг-бефо, кот включ в себя волатайм, синхронайзер и финал
 */
