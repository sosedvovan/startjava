package com.urise.webapp.storage;



import com.urise.webapp.exception.ExistStorageException;
import com.urise.webapp.exception.NotExistStorageException;
import com.urise.webapp.exception.StorageException;
import com.urise.webapp.model.Resume;

import java.util.Arrays;

public abstract class AbstractArrayStorage implements Storage {//абстрактные классы могут не имплементировать методы интерфейса

    //все поля и методы этого абстрактного класса наследуются дочерними наследниками) этого класса:

    protected static final int STORAGE_LIMIT = 100000;//protected = public + видны в наследниках
    protected Resume[] storage = new Resume[STORAGE_LIMIT];//это массив- хранилище Резюме
    protected int size = 0;//инкрементим при добавлении элемента в массив storage и декрементим при удалении элемента
    //будем пользоваться size, тк метод storage.lengths() будет возвращать STORAGE_LIMIT = 100000

    //------------------------------------------------------------------------------------------------------------------

    public void clear() {
        //метод класса Arrays fill заполнит значениями часть массива (от 0 до size)
        //где size типа инклюдев = включается(это можно уточнить в реализации метода)
        //есть реализация без указания интервала (без: от 0 до size)

        Arrays.fill(storage, 0, size, null);
        size = 0;

        //for(int i = 0; i < size; i++){ //один из вариантов очистки массива
        //    storage[i] = null;
        // }
    }

    //------------------------------------------------------------------------------------------------------------------

    public void update(Resume r) {

        // проверка есть ли такое резюме в бд- чтобы оно было
        int index = getIndex(r.getUuid());//getIndex вернет индекс по значению
        //если наш метод getIndex() вернет -1, или отрицат число(от сортированной реализации-предполагаемое положение
        // элемента) то такого объекта в массиве нет:
        if (index < 0) {
            //тк мы создали свои эксэпшены, если такого объекта нет- бросим эксепшен:
            //System.out.println("Resume: " + r.getUuid() + " not exist");//вместо sout:
            throw new NotExistStorageException(r.getUuid());//эксепшен унаследован от RuntimeException -> пробрасывать
            //(throws) в сигнатуре- нельзя



        } else {
            storage[index] = r;//новый объект r уже создан в тестовом-майн классе перед вызовом этого метода
        }

        //вариант моей реализации: //String newUuid - новое значение для Resume r в аргументы метода надо добавить
        // for (int i = 0; i < size; i++) {//чтобы обновить ячейку c Resume сначала найдем ее в цикле for
        //     if (r.getUuid().equals(storage[i].getUuid())) {//в массиве storage лежат объекты Resume -> они вызывают свой геттер
        //          r.setUuid(newUuid); //String newUuid в арг метода должно быть
        //      } //чтобы использовать equals надо его сначала переопределить в Resume
        //  }

    }

//----------------------------------------------------------------------------------------------------------------------

    //клонирует наш массив storage и возвращает новый массив result с размером size
    //чтобы не пользовать огромный массив с 100000 элемнтов, если большинство элементов заполненны дефолтными нулями:
    public Resume[] getAll() {

        //метод Arrays.copyOfRange копирует интервал от 0 индекса до size
        return Arrays.copyOfRange(storage, 0, size);

        // Resume[] result = new Resume[size]; //один из вариантов клонирования массива
        // for(int i = 0; i < size; i++){
        //     result[i] = storage[i];
        //  }
        //  return result;
    }

    //------------------------------------------------------------------------------------------------------------------

    //в этом методе применим ШАБЛОННЫЙ метод. те часть с проверками будет здесь(в родительском классе)
    //а добавление нового элемента будет в первой дочке ArrayStorage методом вставки в конец массива
    //а добавление нового элемента во второй дочке SortedArrayStorage будет через вставку в нужное место- тк массив сортирован
    //распаралерим с пом метода insertElement()- те здесь объявим его абстрактным и реализуем в вышеупомян дочках по-разному
    public void save(Resume r) {
        //проверка есть ли такое резюме в бд- надо чтобы его небыло:
        int index = getIndex(r.getUuid());//сделал рефактор-экстракт вариебл, те getIndex(r.getUuid()) вынесли в int index
        // getIndex вернет индекс по значению
        //или если наш метод getIndex() вернет -1, или отрицат число(из сортированного хранилища) то такого объекта в массиве нет
        //причем модуль отрицательного числа будет равен возможному положению объекта в отсортированном массиве
        if (index >= 0) {//если элемент с таким значением уже есть, то выведем сообщение:
            //System.out.println("Resume: " + r.getUuid() + " alredy exist");
            throw new ExistStorageException(r.getUuid());//это подкласс типа RuntimeException и его не нужно
            // включать в список throws.
        } else if (size == STORAGE_LIMIT) {//проверка-что в массиве еще есть свободные ячейки
            //System.out.println("Storage overflow");
            //для этой ситуации не будем создавать специальное исключение, а бросим родительское:
            throw new StorageException("Storage overflow", r.getUuid());
        } else {// если элемента с таким значением в массиве нет и в массиве есть свободные ячейки:
            insertElement(r, index);//этот абстрактный метод реализуем в дочках(по разному)
            //непонятно-зачем передаем index. понятно: index используем только в методе сортированного класса
            size++;
        }
    }

//----------------------------------------------------------------------------------------------------------------------


    //в этом методе применим шаблонный метод. те часть с проверками будет здесь(в родительском классе)
    //а удаление элемента в дочке ArrayStorage будет методом : на место элемента, который надо удалить
    // поместим последний элемент массива
    //а удаление элемента в дочке SortedArrayStorage будет через удаление элемента и сдвига влево
    //распаралерим с пом метода fillDeletedElement()- те здесь объявим его абстрактным и реализуем в вышеупомян дочках по-разному
    public void delete(String uuid) {
        // сначала проверка есть ли такое резюме в бд- чтобы оно было: //getIndex вернет индекс по значению
        int index = getIndex(uuid);//если наш метод getIndex() вернет -1, или отрицат число то такого объекта в массиве нет
        if (index < 0) {//тк кроме -1 может вернуться просто отрицательное число из отсортированного массива
            //System.out.println("Resume: " + uuid + " not exist");
            throw new NotExistStorageException(uuid);
        } else {
            fillDeletedElement(index);//этот абстрактный метод реализуем в дочках(по разному)
            storage[size - 1] = null;//а на место последнего элемента запишем null
            size--;                 //можно было еще сдвигать влево все элементы находящиеся справа от удаляемого элемента
        }
        //вариант моей реализации:
        //for (int i = 0; i < size; i++) {
        //    if (uuid.equals(storage[i].getUuid())) {
        //        storage[i] = storage[size - 1];//на место элемента, который надо удалить поместим последний элемент массива
        //       storage[size - 1] = null;
        //       size--;
        //    }
        //  }
    }


//----------------------------------------------------------------------------------------------------------------------

    public int size() {
        return size;
    }

    //------------------------------------------------------------------------------------------------------------------

    //метод вернет объект Resume из массива storage с пришедшим в аргументы значением uuid
    //мы создали его в этом абстрактном классе, кот является родительским для SortedArrayStorage и ArrayStorage
    //мы в этот метод вынесли общий механизм для классов SortedArrayStorage и ArrayStorage
    //а в этом методе используется другой-внутренний метод: getIndex()  -> ниже мы его реализуем-сделаем его
    //абстрактным чтобы в классах SortedArrayStorage и ArrayStorage реализовать(переопределить) его по разному
    //это называется ШАБЛОННЫМ МЕТОДОМ - мы переопределим некоторые шаги алгоритма(те мы будем находить индекс
    //в переопределенных getIndex() по разному - перебором и делением на 2)
    public Resume get(String uuid) {

        int index = getIndex(uuid);//находит индекс по значению. если наш метод getIndex() вернет -1, или отрицат число то такого объекта в массиве нет
        if (index < 0) {//тк кроме -1 может вернуться просто отрицательное число из отсортированного массива
            //System.out.println("Resume: " + uuid + " not exist");
            throw new NotExistStorageException(uuid);
           // return null;
        }
        return storage[index];//мы завели int index чтобы в этом(втором) return'е второй раз не запускать getIndex(),
        // те чтобы второй раз не перебирать весь массив (сделали так: рефактор-экстракт)

        //вариант моей реализации обхода массива:
        // for (int i = 0; i < size; i++) {
        //    if (uuid.equals(storage[i].getUuid())) {//в массиве storage лежат объекты Resume -> они вызывают свой геттер
        //        return storage[i];
        //    }
        // }
        // return null;
    }

    //------------------------------------------------------------------------------------------------------------------

    protected abstract int getIndex(String uuid);//в наследниках надо его реализовать как часть шаблонного паттерна
    protected abstract void fillDeletedElement(int index);//в наследниках надо его реализовать как часть шаблонного паттерна
    protected abstract void insertElement(Resume r, int index);//в наследниках надо его реализовать как часть шаблонного паттерна
}



