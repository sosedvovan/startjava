package com.urise.webapp.storage;



import com.urise.webapp.exception.StorageException;
import com.urise.webapp.model.Resume;

import java.util.Arrays;
import java.util.List;

/** <p>
 * абстрактные классы могут не имплементировать абстрактные методы интерфейсов которые они реализуют,
 * и их тогда обязанны будут реализовать наследники.
 * но сечас мы будем их реализовывать.
 *
 * все поля и методы этого абстрактного класса наследуются наследниками (extends AbstractArrayStorage) этого класса.
 *
 * в этом абстрактном классе опишем общие методы для всех его наследников.
 * наследники будут иметь разные реализации в зависимости от вида коллекций на основе которой они работают.
 *
 * из методов этого класса в наследники мы будем выносить часть логики,
 * присущей виду коллекций на которой работает класс. (Шаблонный паттерн)
 *
 </p>*/

//дореализовываем в этом классе методы интерфейса Storage clear(), size() и getAll(), который не реализовали в
//абстрактном классе - родителе этого класса (этот метод получается-пробросился сюда)
//так же реализуем(@Override) абстрактные методы родителя этого класса. Реализуем способом,
// присущим Array'ю (пробрасывать дальше их не будем).

public abstract class AbstractArrayStorage /*implements Storage*/extends AbstractStorage {

    //ПОЛЯ КЛАССА присущие Array'ю:

    //ограничение обычного массива-хранилища
    protected static final int STORAGE_LIMIT = 100000;
    //protected = public + видны в наследниках


    protected Resume[] storage = new Resume[STORAGE_LIMIT];
    //это обычный массив- хранилище Резюме

    protected int size = 0;
    //инкрементим при добавлении элемента в массив storage и декрементим при удалении элемента
    //будем пользоваться size, тк метод storage.lengths() будет возвращать STORAGE_LIMIT = 100000
    //тк пока у нас обычный массив

    //------------------------------------------------------------------------------------------------------------------

    //реализуем здесь абстрактный метод из interface Storage (но и пробросить его можно тк этот класс абстакт)
    @Override
    public void clear() {
        //метод служебного класса Arrays- fill() заполнит значениями часть массива (от 0 до size)
        //где size - инклюдев = включается(это можно уточнить в реализации метода)
        //есть реализация без указания этого интервала (без: от 0 до size)

        Arrays.fill(storage, 0, size, null);
        size = 0;

        //for(int i = 0; i < size; i++){ //один из вариантов очистки массива
        //    storage[i] = null;
        // }
    }

    //------------------------------------------------------------------------------------------------------------------
    // Метод update() ушел отсюда  к родителю реализовываться а  doUpdate() его дошаблонит:

    @Override
    protected void doUpdate(Resume r, Object index) {
        storage[(Integer) index] = r;
        //положили наш апдатный объект Резюме в обычный массив
    }

     /*  //метод принимае объект (Resume r), ищет его индекс по значению поля, если находит - перезаписывает им же)
      public void update(Resume r) {

        // сначала проверка: есть ли такое резюме в бд- надо чтобы оно было.
        int index = getIndex(r.getUuid());
        //getIndex вернет индекс по значению
        //если наш метод getIndex() вернет -1, или отрицат число(от сортированной реализации-предполагаемое положение
        // элемента) то такого объекта в массиве нет:
        if (index < 0) {
            //тк мы создали свои эксэпшены, если такого объекта нет- бросим эксепшен вместо sout:
            //System.out.println("Resume: " + r.getUuid() + " not exist");
            throw new NotExistStorageException(r.getUuid());
            //эксепшен унаследован от RuntimeException -> пробрасывать (throws) в сигнатуре- нельзя

        } else {
            storage[index] = r;
            //новый объект r уже создан в тестовом-майн классе перед вызовом этого метода.
        }

        //вариант первоначальной реализации:
        //метод принимает Resume r, которое надо обновить и
        // String newUuid - новое значение для поля Resume r.
        //чтобы обновить ячейку c Resume сначала найдем ее в цикле for
        // for (int i = 0; i < size; i++) {
        //     if (r.getUuid().equals(storage[i].getUuid())) {
        // в массиве storage лежат объекты Resume -> они вызывают свой геттер для equals
        // далее, при совпадении- перезаписываем поле
        // (но сейчас поле - final и мы перезаписываем объект полностью)
        //          r.setUuid(newUuid);
        //      } //чтобы использовать equals надо его сначала переопределить в Resume
        //  }

    }
    */

  //----------------------------------------------------------------------------------------
  //реализуем здесь абстрактный метод из interface Storage (но и пробросить его можно тк этот класс абстакт)
    @Override
    public List<Resume> doCopyAll() {

        //метод Arrays.copyOfRange() вернет новый скопируемый обычный массив (интервал копирования от 0 индекса до size)
        //Arrays.asList() преобразует обычный массив в лист,
        //и вернет не расширяемый, не ссужаемый список, но кот можно модифицировать -сортировать
        return Arrays.asList(Arrays.copyOfRange(storage, 0, size));
    }
        /*
        // Resume[] result = new Resume[size]; //один из вариантов клонирования массива
        // for(int i = 0; i < size; i++){
        //     result[i] = storage[i];
        //  }
        //  return result;
        //клонирует наш массив storage и возвращает новый массив result с размером size
        //чтобы не пользовать огромный массив с 100000 элемнтов, если большинство элементов заполненны дефолтными нулями:
        */

    //------------------------------------------------------------------------------------------------------------------
    // Метод save() ушел к родителю реализовываться а вместо doSave() его дошаблонит:

    @Override
    //здесь дореализуем проверки
    protected void doSave(Resume r, Object index) {//Ctrl+I -имплементить от родителя
        if (size == STORAGE_LIMIT) {//проверка-что в массиве еще есть свободные ячейки
            //System.out.println("Storage overflow");
            //для этой ситуации не будем создавать специальное исключение, а бросим родительское:
            throw new StorageException("Storage overflow", r.getUuid());
        } else {// если элемента с таким значением в массиве нет и в массиве есть свободные ячейки:
            insertElement(r, (Integer) index);//ссузили тип индекса-но если в аргументах
            //придет не Integer а String, например то будет ClassCastException- далее поправим это
            //insertElement() здесь абстрактный тк для обычного Array и SortedArray будут разные реализации
            size++;
        }
    }


    /*
    //в этом методе применим ШАБЛОННЫЙ метод. те часть с проверками будет здесь(в родительском классе),
    //а добавление нового элемента будет в первой дочке ArrayStorage методом вставки в конец массива,
    //а добавление нового элемента во второй дочке SortedArrayStorage будет через вставку в нужное место- тк массив сортирован
    //распаралерим с пом метода insertElement()- те здесь объявим его абстрактным и реализуем в вышеупомян дочках по-разному
    public void save(Resume r) {
        //проверка есть ли такое резюме в бд- надо чтобы его небыло:
        int index = getSearchKey(r.getUuid());//сделал рефактор-экстракт вариебл, те getIndex(r.getUuid()) вынесли в int index
        // getIndex вернет индекс по значению. Ctrl+Alt+V
        //или если наш метод getIndex() вернет -1 из ArrayStorage, или отрицат число из SortedArrayStorage,
        // то такого объекта в массиве нет.
        //причем модуль отрицательного числа будет равен возможному положению объекта в отсортированном массиве
        if (index >= 0) {//если элемент с таким значением уже есть, то выведем сообщение:
            //System.out.println("Resume: " + r.getUuid() + " alredy exist");
            throw new ExistStorageException(r.getUuid());//это подкласс типа RuntimeException и его не нужно
            // включать в список throws.
        } else if (size == STORAGE_LIMIT) {//проверка-что в массиве еще есть свободные ячейки
            //System.out.println("Storage overflow");
            //для этой ситуации не будем создавать специальное исключение, а бросим родительское:
            throw new StorageException("Storage overflow", r.getUuid());
        } else {// если элемента с таким значением в массиве нет и в массиве есть свободные ячейки:
            insertElement(r, index);//этот абстрактный метод реализуем в дочках(по разному)
            //непонятно-зачем передаем index. понятно: index используем только в методе сортированного класса
            size++;
        }
    }
    */


    //----------------------------------------------------------------------------------------------------------------------
    // Метод delete() ушел к родителю реализовываться а вместо dodelete() его дошаблонит:

    @Override
    protected void doDelete(Object index) {
        fillDeletedElement((Integer) index);//этот абстрактный метод реализуем в дочках(по разному)
        //в fillDeletedElement() удаляемому элементу присвоим крайний элемент
        storage[size - 1] = null;//а на место крайнего элемента запишем null
        size--;                 //можно было еще сдвигать влево все элементы находящиеся справа от удаляемого элемента
    }

    /*
    //в этом методе применим шаблонный метод. те часть с проверками будет здесь(в родительском классе)
    //а удаление элемента в дочке ArrayStorage будет методом : на место элемента, который надо удалить
    // поместим последний элемент массива
    //а удаление элемента в дочке SortedArrayStorage будет через удаление элемента и сдвига влево
    //распаралерим с пом метода fillDeletedElement()- те здесь объявим его абстрактным и реализуем в вышеупомян дочках по-разному
    public void delete(String uuid) {
        // сначала проверка есть ли такое резюме в бд- чтобы оно было: //getIndex вернет индекс по значению
        int index = getSearchKey(uuid);//если наш метод getIndex() вернет -1, или отрицат число то такого объекта в массиве нет
        if (index < 0) {//тк кроме -1 может вернуться просто отрицательное число из отсортированного массива
            //System.out.println("Resume: " + uuid + " not exist");
            throw new NotExistStorageException(uuid);
        } else {
            fillDeletedElement(index);//этот абстрактный метод реализуем в дочках(по разному)
            storage[size - 1] = null;//а на место последнего элемента запишем null
            size--;                 //можно было еще сдвигать влево все элементы находящиеся справа от удаляемого элемента
        }
        //вариант моей реализации:
        //for (int i = 0; i < size; i++) {
        //    if (uuid.equals(storage[i].getUuid())) {
        //        storage[i] = storage[size - 1];//на место элемента, который надо удалить поместим последний элемент массива
        //       storage[size - 1] = null;
        //       size--;
        //    }
        //  }
    }

    */
    //----------------------------------------------------------------------------------------------------------------------

    public int size() {
        return size;
    }

    //------------------------------------------------------------------------------------------------------------------

    // Метод get() ушел к родителю реализовываться а вместо doget() его дошаблонит:

    @Override
    protected Resume doGet(Object index) {//в аргумент придет индекс искомого элемента (в обертке (Integer))
        return storage[(Integer) index];
    }



    /*
    //метод вернет объект Resume из массива storage с пришедшим в аргументы значением uuid
    //мы создали его в этом абстрактном классе, кот является родительским для SortedArrayStorage и ArrayStorage
    //мы в этот метод вынесли общий механизм для классов SortedArrayStorage и ArrayStorage
    //а в этом методе используется другой-внутренний метод: getIndex()  -> ниже мы его реализуем-сделаем его
    //абстрактным чтобы в классах SortedArrayStorage и ArrayStorage реализовать(переопределить) его по разному
    //это называется ШАБЛОННЫМ МЕТОДОМ - мы переопределим некоторые шаги алгоритма(те мы будем находить индекс
    //в переопределенных getIndex() по разному - перебором и делением на 2)
    public Resume get(String uuid) {

        int index = getSearchKey(uuid);//находит индекс по значению. если наш метод getIndex() вернет -1, или отрицат число то такого объекта в массиве нет
        if (index < 0) {//тк кроме -1 может вернуться просто отрицательное число из отсортированного массива
            //System.out.println("Resume: " + uuid + " not exist");
            throw new NotExistStorageException(uuid);
           // return null;
        }
        return storage[index];//мы завели int index чтобы в этом(втором) return'е второй раз не запускать getIndex(),
        // те чтобы второй раз не перебирать весь массив (сделали так: рефактор-экстракт)

        //вариант моей реализации обхода массива:
        // for (int i = 0; i < size; i++) {
        //    if (uuid.equals(storage[i].getUuid())) {//в массиве storage лежат объекты Resume -> они вызывают свой геттер
        //        return storage[i];
        //    }
        // }
        // return null;
    }
    */
    //------------------------------------------------------------------------------------------------------------------


    //в этом классе обычного Array имплементим этот метод как для обычного Array)
    @Override//проверка- существует ли индекс в хранилище
    protected boolean isExist(Object index) {
        return (Integer) index >= 0; //если >= 0 то вернет true -> индекс существует
    }

    //protected abstract int getIndex(String uuid);//изменили название и будем его реализовывать в наследниках
    protected abstract Integer getSearchKey(String uuid);
    //Из дочки-обычного Array возвращает индекс искомого объекта, а если такого объекта нет, возвращает -1
    //Из дочки-обычного SortedArray возвращает индекс искомого объекта а если такого объекта нет, возвращает null?
    //имплементим от родителя и пробрасываем наследникам
    //в наследниках надо его реализовать как часть шаблонного паттерна
    //здесь кавариация- мы ссузили возвращаемый тип(в классе от кот имплементимся-
    //возвращаемый тип- Object)(в детях ссузили)
    //ковариацию в аргументах метода нельзя делать-ошибка компилятора будет


    protected abstract void fillDeletedElement(int index);//в наследниках надо его реализовать как часть шаблонного паттерна
    protected abstract void insertElement(Resume r, int index);//в наследниках надо его реализовать как часть шаблонного паттерна
}



