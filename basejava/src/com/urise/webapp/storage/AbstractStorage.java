package com.urise.webapp.storage;

//абстрактный родительский класс для не ListArray реализаций(а для Мапа и др)
//вынесем в него все проверки, всю логику по максимуму
//скопировав подобие из AbstractArrayStorage(кот начнет имплементится от этотого класса,
//а не интерфейс Storage)
//чтобы дальнейшая реализация хранилища на омнове Мапа и др стала намного проще

//после проверок методы доделоваться будут в дочках с разной реолизацией (Шаблонный)

import com.urise.webapp.exception.ExistStorageException;
import com.urise.webapp.exception.NotExistStorageException;
import com.urise.webapp.model.Resume;

public abstract class AbstractStorage implements Storage {
    //методы size() и clear() getAll() мы сюда не можем скопировать из
    //AbstractArrayStorage тк для Мапа они будут другие

    //-------------------------------------------------------------------------
    //БЛОК АБСТРАКТНЫХ МЕТОДОВ:

    //метод для доапдейта в разных реализациях дочек:
    protected abstract void doUpdate(Resume r, Object searchKey);

    //метод для досохранения в разных реализациях дочек:
    protected abstract void doSave(Resume r, Object searchKey);

    //метод для доудаления в разных реализациях дочек:
    protected abstract void doDelete(Object searchKey);

    //метод для допоказывания Резюме по его значению полей в разных реализациях дочек:
    protected abstract Resume doGet(Object searchKey);

    //метод для проверки- есть ли такой элемент- в разных реализациях дочек:
    //делаем в зависимости от того- какой searchKey (поэтому он типа Object,
    //те  он может быть и int и String)
    protected abstract boolean isExist(Object searchKey);

    //метод getSearchKey() абстрактный вернет индекс по значению
    protected abstract Object getSearchKey(String uuid);
    //в наследниках надо его реализовать как часть шаблонного паттерна

    //-----------------------------------------------------------------------------------
    //БЛОК СЛУЖЕБНЫХ(для убирания дублирования) МЕТОДОВ:

    //внутренний метод для избавления от дублирования кода
    //если ключика не существует- бросаем эксепшн
    //или возвратится searchKey или бросится ексепшн
    //также далее сделаем симметричный метод getNotExistedKey
    private Object getExistedSearchKey(String uuid) {
        Object searchKey = getSearchKey(uuid);
        //метод getSearchKey() абстрактный вернет индекс по значению
        //ему тела будем писать в наследниках- мапе и др
        //помним: что в мапе нет индексов(там беспорядочное распределение пар)

        //создадим метод isExist() для распараллеривания проверки в разных реализациях хранилищ:
        if (!isExist(searchKey)) {
            throw new NotExistStorageException(uuid);
            //эксепшен унаследован от RuntimeException -> пробрасывать (throws) в сигнатуре- нельзя
        }
        return searchKey;
    }

    //если ключик существует- бросаем эксепшн
    //или возвратится searchKey или бросится ексепшн
    private Object getNotExistedSearchKey(String uuid) {
        Object searchKey = getSearchKey(uuid);
        //метод getSearchKey() абстрактный вернет индекс по значению
        //ему тела будем писать в наследниках- мапе и др

        //создадим метод isExist() для распараллеривания проверки в разных реализациях хранилищ:
        if (isExist(searchKey)) {
            throw new ExistStorageException(uuid);
            //эксепшен унаследован от RuntimeException -> пробрасывать (throws) в сигнатуре- нельзя
        }
        return searchKey;
    }

    //----------------------------------------------------------------------------
    //метод принимае объект (Resume r), ищет его индекс по значению поля, если находит - перезаписывает им же)
    public void update(Resume r) {
        // сначала проверка: есть ли такое резюме в бд- надо чтобы оно было.
        Object searchKey = getExistedSearchKey(r.getUuid());
        //getExistedSearchKey() или возвратится существующий ключ поиска searchKey
        // и он отправится на обновление
        // или бросится ексепшн что такого резюме нет в ДБ

        doUpdate(r, searchKey);
            //если объект нашелся делаем doUpdate()
    }

    //----------------------------------------------------------------------------------------------------------------------

    //в этом методе применим ШАБЛОННЫЙ метод. те часть с проверками будет здесь(в родительском классе),
    //а добавление нового элемента будет в первой дочке ... методом ...,
    //а добавление нового элемента во второй дочке ... будет ...
    public void save(Resume r) {
        //проверка есть ли такое резюме в бд- надо чтобы его небыло:
        Object searchKey = getNotExistedSearchKey(r.getUuid());
        //getNotExistedSearchKey() или возвратится не существующий ключ поиска searchKey == null?
        // и он отправится на сохранение
        // или бросится ексепшн что такое резюме уже есть в ДБ

        doSave(r, searchKey);
        //если объект не нашелся делаем doSave()
    }



//----------------------------------------------------------------------------------------------------------------------


    //в этом методе применим шаблонный метод. те часть с проверками будет здесь(в родительском классе)

    public void delete(String uuid) {//далее дублирование кода- избавимся в методе getExistedKey()
        // сначала проверка: есть ли такое резюме в бд- надо чтобы оно было.
        Object searchKey = getExistedSearchKey(uuid);//помним: что в мапе нет индексов(там беспорядочное распределение пар)
        //getExistedSearchKey() или возвратится существующий ключ поиска searchKey
        // и он отправится на доудаление
        // или бросится ексепшн что такого резюме нет в ДБ

        doDelete(searchKey);//этот абстрактный метод реализуем в дочках(по разному)
        //если объект нашелся делаем doDelete(()

       
    }

    //------------------------------------------------------------------------------------------------------------------

    //метод вернет объект Resume из массива storage с пришедшим в аргументы значением uuid
    //мы создали его в этом абстрактном классе, кот является родительским для SortedArrayStorage и ArrayStorage
    //мы в этот метод вынесли общий механизм для классов SortedArrayStorage и ArrayStorage
    //а в этом методе используется другой-внутренний метод: getIndex()  -> ниже мы его реализуем-сделаем его
    //абстрактным чтобы в классах SortedArrayStorage и ArrayStorage реализовать(переопределить) его по разному
    //это называется ШАБЛОННЫМ МЕТОДОМ - мы переопределим некоторые шаги алгоритма(те мы будем находить индекс
    //в переопределенных getIndex() по разному - перебором и делением на 2)
    public Resume get(String uuid) {

        // сначала проверка: есть ли такое резюме в бд- надо чтобы оно было.
        Object searchKey = getExistedSearchKey(uuid);//помним: что в мапе нет индексов(там беспорядочное распределение пар)
        //getExistedSearchKey() или возвратится существующий ключ поиска searchKey
        // и он отправится на допоказывание Резюме по его значению полей
        // или бросится ексепшн что такого резюме нет в ДБ

        return doGet(searchKey);
    }

    //------------------------------------------------------------------------------------------------------------------

}
