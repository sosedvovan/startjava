package com.urise.webapp.storage;

//абстрактный родительский класс
//вынесем в него все проверки, всю логику по максимуму - ПРОВЕРКИ НА СУЩЕСТВУЕТ-НЕСУЩЕСТВУЕТ ВСЕ ЗДЕСЬ
//скопировав подобие из AbstractArrayStorage(кот начнет имплементится от этотого класса,
//а не интерфейс Storage)
//чтобы дальнейшая реализация хранилища на основе Мапа и всех других стала намного проще

//после проверок методы доделоваться будут в дочках с разной реализацией (Шаблонный)

import com.urise.webapp.exception.ExistStorageException;
import com.urise.webapp.exception.NotExistStorageException;
import com.urise.webapp.model.Resume;

import java.util.Collections;
import java.util.List;
import java.util.logging.Logger;


//Object заменили на <SK>-дженерик- след в наследниках этого класса надо добавить:
//------   public class ListStorage extends AbstractStorage<Integer> ------

//и далее во всех классах-наследниках Object заменяем на <Integer> или <String> или <Resume>
// тк в (важном)методе поиска ключа: ---   protected abstract SK getSearchKey(String uuid);   ---
//возвращаемое значение теперь это <...>- ожидаемый тип при декларации дочернего класса
//то мы параметризовали тип ключа-поиска(SearchKey) для разных реализаций хранилищ

// когда реализуем абстрактные методы родительского класса(и далеее можно убрать кастование)
public abstract class AbstractStorage<SK> implements Storage {
    //методы size() и clear() getAll() мы сюда не можем скопировать из
    //AbstractArrayStorage тк для Мапа они будут другие

    //-------------------------------------------------------------------------
    //ЛОГИРОВАНИЕ:
    //чтобы Logger стал единственным для всех экземпляров класса сделаем его
    //не protected, а private static.(те объект Logger создается 1 раз для всех инстансов класса
    // -мы логирование будем делать только в этом классе, в наследниках не будем- поэтому static )
    // след ---- Logger.getLogger(getClass().getName()--- getClass() уже не можем сказать:
    //(если поле принадлежит классу-оно static, то getClass() не можем использовать
    // тк этот метод на объекте вызывается?)
    private static final Logger LOG = Logger.getLogger(AbstractStorage.class.getName());

    //-------------------------------------------------------------------------
    //БЛОК АБСТРАКТНЫХ МЕТОДОВ (перенесли вверх):

    //метод для доапдейта в разных реализациях дочек:
    protected abstract void doUpdate(Resume r, SK searchKey);

    //метод для досохранения в разных реализациях дочек:
    protected abstract void doSave(Resume r, SK searchKey);

    //метод для доудаления в разных реализациях дочек:
    protected abstract void doDelete(SK searchKey);

    //метод для допоказывания Резюме по его значению полей в разных реализациях дочек:
    protected abstract Resume doGet(SK searchKey);

    //метод для проверки- есть ли такой элемент- в разных реализациях дочек:
    //делаем в зависимости от того- какой searchKey (поэтому он типа SK,
    //те  он может быть и int и String)
    //те для обычного Array одна реализация, а для List и Map - другие реализации
    protected abstract boolean isExist(SK searchKey);

    //метод getSearchKey() абстрактный вернет объект по значению его поля
    protected abstract SK getSearchKey(String uuid);
    //в наследниках надо его реализовать как часть шаблонного паттерна

    //поставляет коллекцию, кот надо отсортировать
    protected abstract List<Resume> doCopyAll();

    //-----------------------------------------------------------------------------------
    //БЛОК СЛУЖЕБНЫХ(для убирания дублирования) МЕТОДОВ:

    //внутренний метод для избавления от дублирования кода
    //если ключика(объекта) не существует- бросаем эксепшн
    //или если такой обект существует- возвращаем его в update()->он пойдет в doUpdate()
    // ЭТОТ МЕТОД ИСПОЛЬЗУЕМ В update()
    //также далее сделаем симметричный метод getNotExistedKey
    private SK getExistedSearchKey(String uuid) {

        SK searchKey = getSearchKey(uuid);
        //метод getSearchKey() абстрактный вернет индекс по значению
        //ему разные реализации будем писать в наследниках: Array, List, Map
        //помним: что в мапе нет индексов(там беспорядочное распределение пар)

        //создадим здесь выше абстрактный метод isExist() для распараллеривания проверки в разных реализациях хранилищ:
        if (!isExist(searchKey)) {
            //если объект найден(-приходит true - !переворачиваем на false-  не выбрасываем ексепшен-блок пропускается)
            //и сделаем еще вывод в лог для удобства отслеживания этого эксепшена:
            LOG.warning("Resume " + uuid + " already exist" + uuid);
            throw new NotExistStorageException(uuid);
            //эксепшен унаследован от RuntimeException -> пробрасывать (throws) в сигнатуре- нельзя
        }
        return searchKey;
    }

    //если ключик существует- бросаем эксепшн.
    //или возвратится searchKey или бросится ексепшн
    //ЭТОТ МЕТОД ИСПОЛЬЗУЕМ В save()
    private SK getNotExistedSearchKey(String uuid) {
        SK searchKey = getSearchKey(uuid);
        //метод getSearchKey() абстрактный вернет объект по значению поля uuid
        //ему тела будем писать в наследниках- мапе и др

        //метод isExist()(вернет true- если объект уже существует)
        //создали isExist() для распараллеривания проверки в разных реализациях хранилищ:
        if (isExist(searchKey)) {//true- если объект уже существует и следоват. бросаем эксепшен
            throw new ExistStorageException(uuid);
            //эксепшен унаследован от RuntimeException -> пробрасывать (throws) в сигнатуре- нельзя
        }
        return searchKey;
    }

    //----------------------------------------------------------------------------
    //метод принимае объект (Resume r), ищет его индекс по значению поля, если находит - перезаписывает им же)
    public void update(Resume r) {
        //в каждом методе добавим логирование:
        LOG.info("update" + r);
        // сначала проверка: есть ли такое резюме в бд- надо чтобы оно было.
        SK searchKey = getExistedSearchKey(r.getUuid());
        //getExistedSearchKey() или возвратится существующий ключ поиска searchKey
        // и он отправится на обновление
        // или бросится ексепшн что такого резюме нет в ДБ

        doUpdate(r, searchKey);
            //если объект нашелся делаем doUpdate()
    }

    //----------------------------------------------------------------------------------------------------------------------

    //в этом методе применим ШАБЛОННЫЙ паттерн. те часть с проверками будет здесь(в родительском классе),
    //а добавление нового элемента будет в первой дочке ... методом ...,
    //а добавление нового элемента во второй дочке ... будет ...
    public void save(Resume r) {
        //в каждом методе добавим логирование:
        LOG.info("save" + r);
        //проверка есть ли такое резюме в бд- надо чтобы его небыло:
        SK searchKey = getNotExistedSearchKey(r.getUuid());
        //getNotExistedSearchKey() или возвратится не существующий ключ поиска searchKey == null?
        // и он отправится на сохранение
        // или бросится ексепшн что такое резюме уже есть в ДБ

        doSave(r, searchKey);
        //если объект не нашелся делаем doSave()
    }



//----------------------------------------------------------------------------------------------------------------------


    //в этом методе применим шаблонный метод. те часть с проверками будет здесь(в родительском классе)

    public void delete(String uuid) {//далее дублирование кода- избавимся в методе getExistedKey()
        LOG.info("delete" + uuid);
        // сначала проверка: есть ли такое резюме в бд- надо чтобы оно было.
        SK searchKey = getExistedSearchKey(uuid);//помним: что в мапе нет индексов(там беспорядочное распределение пар)
        //getExistedSearchKey() или возвратится существующий ключ поиска searchKey
        // и он отправится на доудаление
        // или бросится ексепшн что такого резюме нет в ДБ

        doDelete(searchKey);//этот абстрактный метод реализуем в дочках(по разному)
        //если объект нашелся делаем doDelete(()

       
    }

    //Todo: во всех реализациях Storage замените метод Resume[] getAll() на List<Resume> getAllSorted()
    //заимплементировали здесь этот метод Ctrl+I
    //далее тоже шаблонным методом будет передаваться логика
    //то сортировку будем делать только здесь
    @Override
    public List<Resume> getAllSorted() {
        //в каждом методе добавим логирование:
        LOG.info("getAllSorted");
        //doCopyAll() наш абстрактный метод- будет поствалять сюда копию
        //коллекции, которую надо отсортировать
        List<Resume> list = doCopyAll();
        Collections.sort(list);
        return list;
    }



    //------------------------------------------------------------------------------------------------------------------

    //метод вернет объект Resume из массива storage с пришедшим в аргументы значением uuid
    //мы создали его в этом абстрактном классе, кот является родительским для SortedArrayStorage и ArrayStorage
    //мы в этот метод вынесли общий механизм для классов SortedArrayStorage и ArrayStorage
    //а в этом методе используется другой-внутренний метод: getIndex()  -> ниже мы его реализуем-сделаем его
    //абстрактным чтобы в классах SortedArrayStorage и ArrayStorage реализовать(переопределить) его по разному
    //это называется ШАБЛОННЫМ МЕТОДОМ - мы переопределим некоторые шаги алгоритма(те мы будем находить индекс
    //в переопределенных getIndex() по разному - перебором и делением на 2)
    public Resume get(String uuid) {
        //в каждом методе добавим логирование:
        LOG.info("get" + uuid);
        // сначала проверка: есть ли такое резюме в бд- надо чтобы оно было.
        SK searchKey = getExistedSearchKey(uuid);//помним: что в мапе нет индексов(там беспорядочное распределение пар)
        //getExistedSearchKey() или возвратится существующий ключ поиска searchKey
        // и он отправится на допоказывание Резюме по его значению полей
        // или бросится ексепшн что такого резюме нет в ДБ

        return doGet(searchKey);
    }

    //------------------------------------------------------------------------------------------------------------------

}
